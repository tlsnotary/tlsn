use blake3::Hasher;

use mpc_circuits::types::Value;
use serde::{Deserialize, Serialize};

use crate::{encoding_state, EncodedValue};

/// A hash value used in dual-execution mode to check equality of two sets of encodings.
///
/// In dual-execution mode, both parties generate a garbled circuit which have their own
/// respective encodings of the output values. Both parties then evaluate the other's circuit
/// to learn the _active_ encoding of the output values. The parties then perform a secure
/// equality check to ensure that the output values are equal.
///
/// This equality check guarantees the authenticity of the decoded output values.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct EqualityCheck([u8; 32]);

impl EqualityCheck {
    /// Creates a new equality check value from the given encodings and purported
    /// values.
    ///
    /// # Arguments
    ///
    /// * `our_encodings` - Our full encodings of the values.
    /// * `peer_encodings` - Active encodings of the values generated by the peer.
    /// * `purported_values` - The purported values.
    /// * `order` - Used to control the order of the encodings in the hash.
    ///
    /// # Panics
    ///
    /// Panics if the lengths of the given slices are not equal, or if the
    /// provided values have a different type than the encodings.
    pub fn new(
        our_encodings: &[EncodedValue<encoding_state::Full>],
        peer_encodings: &[EncodedValue<encoding_state::Active>],
        purported_values: &[Value],
        order: bool,
    ) -> Self {
        assert_eq!(our_encodings.len(), peer_encodings.len());
        assert_eq!(our_encodings.len(), purported_values.len());

        let mut hasher = Hasher::new();

        let our_active_iter = our_encodings.iter().zip(purported_values).flat_map(
            |(full_encoding, purported_value)| {
                full_encoding
                    .select(purported_value.clone())
                    .expect("value type should match encoding type")
                    .iter()
                    .flat_map(|label| label.to_inner().to_be_bytes())
                    .collect::<Vec<_>>()
            },
        );
        let peer_active_iter = peer_encodings.iter().flat_map(|encoded| {
            encoded
                .iter()
                .flat_map(|label| label.to_inner().to_be_bytes())
        });

        let bytes: Vec<u8> = if order {
            our_active_iter.chain(peer_active_iter).collect()
        } else {
            peer_active_iter.chain(our_active_iter).collect()
        };

        hasher.update(&bytes);

        EqualityCheck(hasher.finalize().into())
    }
}
