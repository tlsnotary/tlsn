{"noir_version":"1.0.0-beta.8+ba05d729b9753aa5ce2b076c1dd4795edb173f68","hash":"4238770051219268338","abi":{"parameters":[{"name":"proof_date","type":{"kind":"struct","path":"date::date::Date","fields":[{"name":"day","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"month","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"year","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"public"},{"name":"committed_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"date_of_birth","type":{"kind":"string","length":10},"visibility":"private"},{"name":"blinder","type":{"kind":"array","length":16,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6668324276689745315":{"error_kind":"string","string":"Field failed to decompose into specified 4 limbs"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n}\n","path":"std/cmp.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"22":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n","path":"std/lib.nr"},"50":{"source":"use dep::date::Date;\n\nfn main(\n    // Public inputs\n    proof_date: pub date::Date, // \"2025-08-29\"\n    committed_hash: pub [u8; 32], // Hash of (blinder || dob string)\n    // Private inputs\n    date_of_birth: str<10>, // \"1985-03-12\"\n    blinder: [u8; 16], // Random 16-byte blinder\n) {\n    let is_18 = check_18(date_of_birth, proof_date);\n\n    let correct_hash = check_hash(date_of_birth, blinder, committed_hash);\n\n    assert(correct_hash);\n    assert(is_18);\n}\n\nfn check_18(date_of_birth: str<10>, proof_date: date::Date) -> bool {\n    let dob = parse_birth_date(date_of_birth);\n    let is_18 = dob.add_years(18).lt(proof_date);\n    println(f\"Is 18? {is_18}\");\n    is_18\n}\n\nfn check_hash(date_of_birth: str<10>, blinder: [u8; 16], committed_hash: [u8; 32]) -> bool {\n    let hash_input: [u8; 26] = make_hash_input(date_of_birth, blinder);\n    let computed_hash = sha256::sha256_var(hash_input, 26);\n    let correct_hash = computed_hash == committed_hash;\n    println(f\"Correct hash? {correct_hash}\");\n    correct_hash\n}\n\nfn make_hash_input(dob: str<10>, blinder: [u8; 16]) -> [u8; 26] {\n    let mut input: [u8; 26] = [0; 26];\n    for i in 0..10 {\n        input[i] = dob.as_bytes()[i];\n    }\n    for i in 0..16 {\n        input[10 + i] = blinder[i];\n    }\n    input\n}\n\npub fn parse_birth_date(birth_date: str<10>) -> date::Date {\n    let date: [u8; 10] = birth_date.as_bytes();\n    let date_str: str<8> =\n        [date[0], date[1], date[2], date[3], date[5], date[6], date[8], date[9]].as_str_unchecked();\n    Date::from_str_long_year(date_str)\n}\n\n#[test]\nfn test_max_is_over_18() {\n    // Private input\n    let date_of_birth = \"1985-03-12\";\n    let blinder = [120, 80, 62, 10, 76, 60, 130, 98, 147, 161, 139, 126, 27, 236, 36, 56];\n\n    // Public input\n    let proof_date = date::Date { year: 2025, month: 9, day: 2 };\n    let committed_hash = [\n        229, 118, 202, 216, 213, 230, 125, 163, 48, 178, 118, 225, 84, 7, 140, 63, 173, 255, 163,\n        208, 163, 3, 63, 204, 37, 120, 254, 246, 202, 116, 122, 145,\n    ];\n\n    main(proof_date, committed_hash, date_of_birth, blinder);\n}\n\n#[test(should_fail)]\nfn test_under_18() {\n    // Private input\n    let date_of_birth = \"2010-08-01\";\n    let blinder = [160, 23, 57, 158, 141, 195, 155, 132, 109, 242, 48, 220, 70, 217, 229, 189];\n\n    // Public input\n    let proof_date = date::Date { year: 2025, month: 8, day: 29 };\n    let committed_hash = [\n        16, 132, 194, 62, 232, 90, 157, 153, 4, 231, 1, 54, 226, 3, 87, 174, 129, 177, 80, 69, 37,\n        222, 209, 91, 168, 156, 9, 109, 108, 144, 168, 109,\n    ];\n\n    main(proof_date, committed_hash, date_of_birth, blinder);\n}\n","path":"/Users/heeckhau/tlsnotary/tlsn/crates/examples/interactive_zk/noir/src/main.nr"},"51":{"source":"use std::cmp::Eq;\nuse std::println;\n\nglobal UNIX_EPOCH_YEAR: u32 = 1970;\nglobal SECONDS_IN_DAY: u32 = 86400;\n\npub struct Date {\n    pub day: u8,\n    pub month: u8,\n    pub year: u32,\n}\n\nfn get_number_from_utf8_code(code: u8) -> u8 {\n    assert(code >= 48 & code <= 57);\n    code - 48\n}\n\nfn number_to_utf8_code(number: u8) -> u8 {\n    assert(number >= 0 & number <= 9);\n    number + 48\n}\n\nimpl Date {\n    pub fn new(year: u32, month: u8, day: u8) -> Self {\n        assert(month >= 1 & month <= 12);\n        assert(day >= 1 & day <= 31);\n        let date = Self { day: day, month: month, year: year };\n        assert(day <= date.get_days_in_month(month));\n        date\n    }\n\n    pub fn from_bytes_short_year(date: [u8; 6], threshold_date: Date) -> Self {\n        let firstYearDigit = get_number_from_utf8_code(date[0]);\n        let secondYearDigit = get_number_from_utf8_code(date[1]);\n\n        let mut year: u32 = firstYearDigit as u32 * 10 + secondYearDigit as u32;\n\n        let firstMonthDigit = get_number_from_utf8_code(date[2]);\n        let secondMonthDigit = get_number_from_utf8_code(date[3]);\n\n        let month = firstMonthDigit * 10 + secondMonthDigit;\n\n        let firstDayDigit = get_number_from_utf8_code(date[4]);\n        let secondDayDigit = get_number_from_utf8_code(date[5]);\n\n        let day = firstDayDigit * 10 + secondDayDigit;\n\n        let mut currentYear: u32 = threshold_date.year % 100;\n\n        // This way we have a smooth 100 years period according to a threshold year\n        // Taking the current year as threshold year (for birthdates for example)\n        // if the current year is 2023, then 24 will be interpreted as 1924\n        // while 22 will be interpreted as 2022\n        // A bit problematic for people over 100 years old\n        if year <= currentYear {\n            year += 2000;\n        } else {\n            year += 1900;\n        }\n\n        Self { day: day, month: month, year: year }\n    }\n\n    pub fn from_bytes_long_year(date: [u8; 8]) -> Self {\n        let firstYearDigit = get_number_from_utf8_code(date[0]);\n        let secondYearDigit = get_number_from_utf8_code(date[1]);\n        let thirdYearDigit = get_number_from_utf8_code(date[2]);\n        let fourthYearDigit = get_number_from_utf8_code(date[3]);\n\n        let year: u32 = firstYearDigit as u32 * 1000\n            + secondYearDigit as u32 * 100\n            + thirdYearDigit as u32 * 10\n            + fourthYearDigit as u32;\n\n        let firstMonthDigit = get_number_from_utf8_code(date[4]);\n        let secondMonthDigit = get_number_from_utf8_code(date[5]);\n\n        let month = firstMonthDigit * 10 + secondMonthDigit;\n\n        let firstDayDigit = get_number_from_utf8_code(date[6]);\n        let secondDayDigit = get_number_from_utf8_code(date[7]);\n\n        let day = firstDayDigit * 10 + secondDayDigit;\n\n        Self { day: day, month: month, year: year }\n    }\n\n    pub fn from_str_short_year(date: str<6>, threshold_date: Date) -> Self {\n        let date_bytes = date.as_bytes();\n        Date::from_bytes_short_year(date_bytes, threshold_date)\n    }\n\n    pub fn from_str_long_year(date: str<8>) -> Self {\n        let date_bytes = date.as_bytes();\n        Date::from_bytes_long_year(date_bytes)\n    }\n\n    fn count_leap_years_since_epoch(year: u32, epoch_year: u32) -> u32 {\n        let y = year - 1;\n        let leaps_up_to_y = y / 4 - y / 100 + y / 400;\n        let leaps_up_to_epoch_year =\n            (epoch_year - 1) / 4 - (epoch_year - 1) / 100 + (epoch_year - 1) / 400;\n        leaps_up_to_y - leaps_up_to_epoch_year\n    }\n\n    fn days_since_epoch(year: u32, epoch_year: u32) -> u32 {\n        365 * (year - epoch_year) + Date::count_leap_years_since_epoch(year, epoch_year)\n    }\n\n    fn estimate_start_day_and_year(days: u32, epoch_year: u32) -> (u32, u32) {\n        let first_guess_year = epoch_year + days / 365;\n\n        let days_lower_bound = if first_guess_year > epoch_year {\n            Date::days_since_epoch(first_guess_year - 1, epoch_year)\n        } else {\n            0\n        };\n        let day_guess = Date::days_since_epoch(first_guess_year, epoch_year);\n        let days_upper_bound = Date::days_since_epoch(first_guess_year + 1, epoch_year);\n\n        let use_lower_bound = (days >= days_lower_bound) & (days < day_guess);\n        let use_upper_bound = days >= days_upper_bound;\n\n        let mut best_year = first_guess_year;\n        let mut best_start_day = day_guess;\n\n        best_year = if use_lower_bound {\n            first_guess_year - 1\n        } else {\n            best_year\n        };\n        best_start_day = if use_lower_bound {\n            days_lower_bound\n        } else {\n            best_start_day\n        };\n\n        best_year = if use_upper_bound {\n            first_guess_year + 1\n        } else {\n            best_year\n        };\n        best_start_day = if use_upper_bound {\n            days_upper_bound\n        } else {\n            best_start_day\n        };\n\n        (best_year, best_start_day)\n    }\n\n    pub fn from_timestamp_with_epoch(timestamp: u64, epoch_year: u32) -> Self {\n        let days = timestamp / SECONDS_IN_DAY as u64;\n        let (year, year_start_day) = Date::estimate_start_day_and_year(days as u32, epoch_year);\n        let day_of_year = days as u32 - year_start_day;\n\n        let is_leap = Date::is_leap_year(Date::new(year, 1, 1));\n\n        let days_at_month_start: [u32; 13] = if is_leap {\n            [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]\n        } else {\n            [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]\n        };\n\n        let mut month: u32 = 1;\n        for i in 0..12 {\n            let advance = day_of_year >= days_at_month_start[i + 1];\n            month = if advance { month + 1 } else { month };\n        }\n\n        let day: u32 = day_of_year - days_at_month_start[(month - 1) as u32] + 1;\n        Date::new(year, month as u8, day as u8)\n    }\n\n    pub fn from_timestamp(timestamp: u64) -> Self {\n        Date::from_timestamp_with_epoch(timestamp, UNIX_EPOCH_YEAR)\n    }\n\n    pub fn get_duration_in_days(self: Self, other: Self, absolute: bool) -> i64 {\n        let mut duration_years = self.get_duration_between_years(other);\n        let mut duration_months = self.get_duration_between_months(other);\n        let mut duration_days = self.day as i64 - other.day as i64;\n        if (self.year < other.year) {\n            if (other.is_leap_year() & other.month > 2 & self.month > 2) {\n                duration_days -= 1;\n            }\n        } else if (self.year > other.year) {\n            if (self.is_leap_year() & self.month > 2 & other.month > 2) {\n                duration_days += 1;\n            }\n        }\n        let totalDuration: i64 = duration_years + duration_months + duration_days;\n\n        if (totalDuration < 0) & absolute {\n            -1 * totalDuration\n        } else {\n            totalDuration\n        }\n    }\n\n    pub fn gt(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) > 0\n    }\n\n    pub fn lt(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) < 0\n    }\n\n    pub fn eq(self: Self, other: Self) -> bool {\n        (self.day == other.day) & (self.month == other.month) & (self.year == other.year)\n    }\n\n    pub fn ne(self: Self, other: Self) -> bool {\n        !self.eq(other)\n    }\n\n    pub fn gte(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) >= 0\n    }\n\n    pub fn lte(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) <= 0\n    }\n\n    pub fn println(self: Self) {\n        let year = self.year;\n        let month = self.month;\n        let day = self.day;\n        // Let's write the date in the YYYY-MM-DD format\n        // since people don't agree on which format is best\n        // between MM/DD/YYYY and DD/MM/YYYY\n        if (month < 10) & (day < 10) {\n            println(f\"Date: {year}-0{month}-0{day}\");\n        } else if month < 10 {\n            println(f\"Date: {year}-0{month}-{day}\");\n        } else if day < 10 {\n            println(f\"Date: {year}-{month}-0{day}\");\n        } else {\n            println(f\"Date: {year}-{month}-{day}\");\n        }\n    }\n\n    pub fn to_bytes(self: Self) -> [u8; 8] {\n        let mut date: [u8; 8] = [0; 8];\n\n        let firstYearDigit = self.year / 1000;\n        let secondYearDigit = (self.year - firstYearDigit * 1000) / 100;\n        let thirdYearDigit = (self.year - firstYearDigit * 1000 - secondYearDigit * 100) / 10;\n        let fourthYearDigit =\n            self.year - firstYearDigit * 1000 - secondYearDigit * 100 - thirdYearDigit * 10;\n\n        date[0] = number_to_utf8_code(firstYearDigit as u8);\n        date[1] = number_to_utf8_code(secondYearDigit as u8);\n        date[2] = number_to_utf8_code(thirdYearDigit as u8);\n        date[3] = number_to_utf8_code(fourthYearDigit as u8);\n\n        let firstMonthDigit = self.month / 10;\n        let secondMonthDigit = self.month - firstMonthDigit * 10;\n\n        date[4] = number_to_utf8_code(firstMonthDigit as u8);\n        date[5] = number_to_utf8_code(secondMonthDigit as u8);\n\n        let firstDayDigit = self.day / 10;\n        let secondDayDigit = self.day - firstDayDigit * 10;\n\n        date[6] = number_to_utf8_code(firstDayDigit as u8);\n        date[7] = number_to_utf8_code(secondDayDigit as u8);\n\n        date\n    }\n\n    pub fn to_string(self: Self) -> str<8> {\n        let date_bytes = self.to_bytes();\n        date_bytes.as_str_unchecked()\n    }\n\n    pub fn to_timestamp_with_epoch(self: Self, epoch_year: u32) -> u32 {\n        let days = self.get_duration_in_days(Date::new(epoch_year, 1, 1), true);\n        days as u32 * SECONDS_IN_DAY\n    }\n\n    pub fn to_timestamp(self: Self) -> u32 {\n        self.to_timestamp_with_epoch(UNIX_EPOCH_YEAR)\n    }\n\n    pub fn is_leap_year(self: Self) -> bool {\n        ((self.year % 4 == 0) & (self.year % 100 != 0)) | (self.year % 400 == 0)\n    }\n\n    pub fn leap_year_count(year: u32) -> i32 {\n        (year / 4) as i32 - (year / 100) as i32 + (year / 400) as i32\n    }\n\n    pub fn get_days_in_month(self: Self, month: u8) -> u8 {\n        assert(month >= 1 & month <= 12);\n        if month == 2 {\n            if self.is_leap_year() {\n                29\n            } else {\n                28\n            }\n        } else {\n            if (month == 1)\n                | (month == 3)\n                | (month == 5)\n                | (month == 7)\n                | (month == 8)\n                | (month == 10)\n                | (month == 12) {\n                31\n            } else {\n                30\n            }\n        }\n    }\n\n    pub fn get_duration_between_months(self: Self, other: Self) -> i64 {\n        assert(self.month >= 1 & self.month <= 12);\n        assert(other.month >= 1 & other.month <= 12);\n        let mut duration: i64 = 0;\n        if (self.month < other.month) {\n            for month in 1..13 {\n                if month >= self.month & month < other.month {\n                    duration -= other.get_days_in_month(month) as i64;\n                }\n            }\n        } else {\n            for month in 1..13 {\n                if month >= other.month & month < self.month {\n                    duration += self.get_days_in_month(month) as i64;\n                }\n            }\n        }\n        duration\n    }\n\n    pub fn get_duration_between_years(self: Self, other: Self) -> i64 {\n        let mut duration: i64 = 0;\n        if (self.year < other.year) {\n            let mut leap_year_count: i32 =\n                Date::leap_year_count(other.year - 1) - Date::leap_year_count(self.year);\n            if self.is_leap_year() {\n                leap_year_count += 1;\n            }\n            duration -= leap_year_count as i64 * 366;\n            duration -=\n                (other.year as i64 - self.year as i64 - leap_year_count as i64) as i64 * 365;\n        } else if (self.year > other.year) {\n            let mut leap_year_count: i32 =\n                Date::leap_year_count(self.year - 1) - Date::leap_year_count(other.year);\n            if other.is_leap_year() {\n                leap_year_count += 1;\n            }\n            duration += leap_year_count as i64 * 366;\n            duration +=\n                (self.year as i64 - other.year as i64 - leap_year_count as i64) as i64 * 365;\n        }\n        duration\n    }\n\n    pub fn add_years(self: Self, years: u32) -> Self {\n        Self { day: self.day, month: self.month, year: self.year + years }\n    }\n\n    pub fn sub_years(self: Self, years: u32) -> Self {\n        Self { day: self.day, month: self.month, year: self.year - years }\n    }\n\n    pub fn add_months(self: Self, months: u32) -> Self {\n        let mut newMonth = self.month as u32 + months;\n        let mut newYear = self.year;\n        let yearToAdd = (newMonth - 1) / 12;\n        if newMonth > 12 {\n            newYear += yearToAdd as u32;\n            newMonth -= 12 * yearToAdd;\n        }\n        Self { day: self.day, month: newMonth as u8, year: newYear }\n    }\n\n    pub fn sub_months(self: Self, months: u32) -> Self {\n        let mut newMonth = self.month as i32 - months as i32;\n        let mut newYear = self.year;\n        if newMonth < 1 {\n            let yearToSub = ((newMonth as i32 - 12 as i32) * -1) / 12;\n            newYear -= yearToSub as u32;\n            newMonth += 12 * yearToSub;\n        }\n        Self { day: self.day, month: newMonth as u8, year: newYear }\n    }\n\n    pub fn add_days(self: Self, days: u32) -> Self {\n        let mut newDay = self.day as u32 + days;\n        let mut newMonth = self.month as u32;\n        let mut newYear = self.year;\n        let mut date = Self { day: newDay as u8, month: newMonth as u8, year: newYear };\n        if newDay > self.get_days_in_month(self.month) as u32 {\n            let max_months = (newDay / 30) + 1;\n            let bound = self.month as u64 + max_months as u64;\n            for _ in self.month as u64..bound as u64 {\n                let days_in_month = date.get_days_in_month(newMonth as u8) as u32;\n                if newDay > days_in_month {\n                    newDay -= days_in_month;\n                    newMonth += 1;\n                    if newMonth > 12 {\n                        newYear += 1;\n                        newMonth = 1;\n                    }\n                    // We need to mutate the date object inside the loop\n                    // so we can use get_days_in_month properly\n                    date.day = newDay as u8;\n                    date.year = newYear;\n                    date.month = newMonth as u8;\n                }\n            }\n        }\n        date\n    }\n\n    // Performance could be improved\n    pub fn sub_days(self: Self, days: u32) -> Self {\n        let mut newDay = self.day as i32 - days as i32;\n        let mut newMonth = self.month as i32;\n        let mut newYear = self.year;\n        let mut date = Self { day: newDay as u8, month: newMonth as u8, year: newYear };\n        if newDay < 1 {\n            let max_months = (self.day as u32 + days) / 30 + 1;\n            let bound = self.month as u64 + max_months as u64;\n            for _ in self.month as u64..bound as u64 {\n                let days_in_month = date.get_days_in_month(newMonth as u8) as i32;\n                if newDay < 1 {\n                    newDay += days_in_month;\n                    newMonth -= 1;\n                    if newMonth < 1 {\n                        newYear -= 1;\n                        newMonth = 12;\n                    }\n                    // We need to mutate the date object inside the loop\n                    // so we can use get_days_in_month properly\n                    date.day = newDay as u8;\n                    date.year = newYear;\n                    date.month = newMonth as u8;\n                }\n            }\n        }\n        date\n    }\n}\n\nimpl Eq for Date {\n    fn eq(self: Self, other: Self) -> bool {\n        self.eq(other)\n    }\n}\n","path":"/Users/heeckhau/nargo/github.com/madztheo/noir-date.git/v0.5.4/src/date.nr"},"62":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let (mut h, mut msg_block, mut msg_byte_ptr) =\n            process_full_blocks(msg, message_size, INITIAL_STATE);\n\n        finalize_sha256_blocks(msg, message_size, N, h, msg_block, msg_byte_ptr)\n    }\n}\n\npub(crate) unconstrained fn __sha_var<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    initial_state: STATE,\n) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = initial_state;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n\n    finalize_last_sha256_block(h, message_size, msg)\n}\n\n// Helper function to finalize the message block with padding and length\npub(crate) unconstrained fn finalize_last_sha256_block<let N: u32>(\n    mut h: STATE,\n    message_size: u32,\n    msg: [u8; N],\n) -> HASH {\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    __sha_var(msg, message_size, INITIAL_STATE)\n}\n\npub(crate) fn process_full_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    mut h: STATE,\n) -> (STATE, MSG_BLOCK, u32) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    let mut msg_byte_ptr = 0;\n    let num_blocks = N / BLOCK_SIZE;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n        // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        // Verify the block we are compressing was appropriately constructed\n        let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n        if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n    (h, msg_block, msg_byte_ptr)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\npub(crate) unconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let int_input = (block_input + INT_SIZE - 1) / INT_SIZE;\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\n#[inline_always]\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    msg_block[INT_SIZE_PTR] = (len_bytes[0] as u32) << 24\n        | (len_bytes[1] as u32) << 16\n        | (len_bytes[2] as u32) << 8\n        | (len_bytes[3] as u32);\n\n    msg_block[INT_SIZE_PTR + 1] = (len_bytes[4] as u32) << 24\n        | (len_bytes[5] as u32) << 16\n        | (len_bytes[6] as u32) << 8\n        | (len_bytes[7] as u32);\n\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    std::static_assert(\n        INT_SIZE_PTR + 2 == INT_BLOCK_SIZE,\n        \"INT_SIZE_PTR + 2 must equal INT_BLOCK_SIZE\",\n    );\n    let reconstructed_len_hi = msg_block[INT_SIZE_PTR] as Field;\n    let reconstructed_len_lo = msg_block[INT_SIZE_PTR + 1] as Field;\n\n    let reconstructed_len: Field =\n        reconstructed_len_hi * TWO_POW_32 as Field + reconstructed_len_lo;\n    let len = 8 * (message_size as Field);\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\npub(crate) fn finalize_sha256_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    total_len: u32,\n    mut h: STATE,\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: u32,\n) -> HASH {\n    let modulo = total_len % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let num_blocks = total_len / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n        // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n        if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n            verify_msg_block_padding(msg_block, msg_byte_ptr);\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    // Safety: separate verification function\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            __sha_partial_var_interstitial(h, msg, message_size)\n        }\n    } else {\n        let (mut h, _, _) = process_full_blocks(msg, message_size, h);\n\n        h\n    }\n}\n\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the current chunk\n * @param real_message_size - the total size of the original preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n    real_message_size: u32,\n) -> [u8; 32] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            h = __sha_partial_var_interstitial(h, msg, message_size);\n\n            // Handle setup of the final msg block.\n            // This case is only hit if the msg is less than the block size,\n            // or our message cannot be evenly split into blocks.\n\n            finalize_last_sha256_block(h, real_message_size, msg)\n        }\n    } else {\n        let (mut h, mut msg_block, mut msg_byte_ptr) = process_full_blocks(msg, message_size, h);\n        finalize_sha256_blocks(msg, real_message_size, N, h, msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn __sha_partial_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n    h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n","path":"/Users/heeckhau/nargo/github.com/noir-lang/sha256/v0.1.5/src/sha256.nr"}},"names":["main"],"brillig_names":["print_unconstrained","build_msg_block","attach_len_to_msg_block","print_unconstrained","directive_integer_quotient","directive_invert","directive_to_radix"]}