{"noir_version":"1.0.0-beta.8+ba05d729b9753aa5ce2b076c1dd4795edb173f68","hash":"6447387000763501186","abi":{"parameters":[{"name":"proof_date","type":{"kind":"struct","path":"date::date::Date","fields":[{"name":"day","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"month","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"year","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"public"},{"name":"committed_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"date_of_birth","type":{"kind":"string","length":10},"visibility":"private"},{"name":"blinder","type":{"kind":"array","length":16,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n}\n","path":"std/cmp.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"22":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n","path":"std/lib.nr"},"50":{"source":"use dep::date::Date;\n\nfn main(\n    // Public inputs\n    proof_date: pub date::Date, // \"2025-08-29\"\n    committed_hash: pub [u8; 32], // Hash of (blinder || dob string)\n    // Private inputs\n    date_of_birth: str<10>, // \"1985-03-12\"\n    blinder: [u8; 16], // Random 16-byte blinder\n) {\n    let is_18 = check_18(date_of_birth, proof_date);\n\n    let correct_hash = check_hash(date_of_birth, blinder, committed_hash);\n\n    assert(correct_hash);\n    assert(is_18);\n}\n\nfn check_18(date_of_birth: str<10>, proof_date: date::Date) -> bool {\n    let dob = parse_birth_date(date_of_birth);\n    let is_18 = dob.add_years(18).lt(proof_date);\n    println(f\"Is 18? {is_18}\");\n    is_18\n}\n\nfn check_hash(date_of_birth: str<10>, blinder: [u8; 16], committed_hash: [u8; 32]) -> bool {\n    let hash_input: [u8; 26] = make_hash_input(date_of_birth, blinder);\n    let computed_hash = std::hash::blake3(hash_input);\n    let correct_hash = computed_hash == committed_hash;\n    println(f\"Correct hash? {correct_hash}\");\n    correct_hash\n}\n\nfn make_hash_input(dob: str<10>, blinder: [u8; 16]) -> [u8; 26] {\n    let mut input: [u8; 26] = [0; 26];\n    for i in 0..10 {\n        input[i] = dob.as_bytes()[i];\n    }\n    for i in 0..16 {\n        input[10 + i] = blinder[i];\n    }\n    input\n}\n\npub fn parse_birth_date(birth_date: str<10>) -> date::Date {\n    let date: [u8; 10] = birth_date.as_bytes();\n    let date_str: str<8> =\n        [date[0], date[1], date[2], date[3], date[5], date[6], date[8], date[9]].as_str_unchecked();\n    Date::from_str_long_year(date_str)\n}\n\n#[test]\nfn test_max_is_over_18() {\n    // Private input\n    let date_of_birth = \"1985-03-12\";\n    let blinder = [109, 224, 222, 179, 60, 44, 41, 65, 166, 94, 111, 216, 73, 231, 63, 83];\n\n    // Public input\n    let proof_date = date::Date { year: 2025, month: 9, day: 26 };\n    let committed_hash = [\n        114, 34, 41, 235, 91, 156, 13, 57, 254, 112, 250, 35, 104, 217, 20, 182, 240, 170, 57, 39,\n        187, 154, 14, 39, 91, 67, 50, 199, 149, 231, 78, 46,\n    ];\n\n    main(proof_date, committed_hash, date_of_birth, blinder);\n}\n\n#[test(should_fail)]\nfn test_under_18() {\n    // Private input\n    let date_of_birth = \"2010-08-01\";\n    let blinder = [160, 23, 57, 158, 141, 195, 155, 132, 109, 242, 48, 220, 70, 217, 229, 189];\n\n    // Public input\n    let proof_date = date::Date { year: 2025, month: 8, day: 29 };\n    let committed_hash = [\n        16, 132, 194, 62, 232, 90, 157, 153, 4, 231, 1, 54, 226, 3, 87, 174, 129, 177, 80, 69, 37,\n        222, 209, 91, 168, 156, 9, 109, 108, 144, 168, 109,\n    ];\n\n    main(proof_date, committed_hash, date_of_birth, blinder);\n}\n","path":"/Users/heeckhau/tlsnotary/tlsn/crates/examples/interactive_zk/noir/src/main.nr"},"51":{"source":"use std::cmp::Eq;\nuse std::println;\n\nglobal UNIX_EPOCH_YEAR: u32 = 1970;\nglobal SECONDS_IN_DAY: u32 = 86400;\n\npub struct Date {\n    pub day: u8,\n    pub month: u8,\n    pub year: u32,\n}\n\nfn get_number_from_utf8_code(code: u8) -> u8 {\n    assert(code >= 48 & code <= 57);\n    code - 48\n}\n\nfn number_to_utf8_code(number: u8) -> u8 {\n    assert(number >= 0 & number <= 9);\n    number + 48\n}\n\nimpl Date {\n    pub fn new(year: u32, month: u8, day: u8) -> Self {\n        assert(month >= 1 & month <= 12);\n        assert(day >= 1 & day <= 31);\n        let date = Self { day: day, month: month, year: year };\n        assert(day <= date.get_days_in_month(month));\n        date\n    }\n\n    pub fn from_bytes_short_year(date: [u8; 6], threshold_date: Date) -> Self {\n        let firstYearDigit = get_number_from_utf8_code(date[0]);\n        let secondYearDigit = get_number_from_utf8_code(date[1]);\n\n        let mut year: u32 = firstYearDigit as u32 * 10 + secondYearDigit as u32;\n\n        let firstMonthDigit = get_number_from_utf8_code(date[2]);\n        let secondMonthDigit = get_number_from_utf8_code(date[3]);\n\n        let month = firstMonthDigit * 10 + secondMonthDigit;\n\n        let firstDayDigit = get_number_from_utf8_code(date[4]);\n        let secondDayDigit = get_number_from_utf8_code(date[5]);\n\n        let day = firstDayDigit * 10 + secondDayDigit;\n\n        let mut currentYear: u32 = threshold_date.year % 100;\n\n        // This way we have a smooth 100 years period according to a threshold year\n        // Taking the current year as threshold year (for birthdates for example)\n        // if the current year is 2023, then 24 will be interpreted as 1924\n        // while 22 will be interpreted as 2022\n        // A bit problematic for people over 100 years old\n        if year <= currentYear {\n            year += 2000;\n        } else {\n            year += 1900;\n        }\n\n        Self { day: day, month: month, year: year }\n    }\n\n    pub fn from_bytes_long_year(date: [u8; 8]) -> Self {\n        let firstYearDigit = get_number_from_utf8_code(date[0]);\n        let secondYearDigit = get_number_from_utf8_code(date[1]);\n        let thirdYearDigit = get_number_from_utf8_code(date[2]);\n        let fourthYearDigit = get_number_from_utf8_code(date[3]);\n\n        let year: u32 = firstYearDigit as u32 * 1000\n            + secondYearDigit as u32 * 100\n            + thirdYearDigit as u32 * 10\n            + fourthYearDigit as u32;\n\n        let firstMonthDigit = get_number_from_utf8_code(date[4]);\n        let secondMonthDigit = get_number_from_utf8_code(date[5]);\n\n        let month = firstMonthDigit * 10 + secondMonthDigit;\n\n        let firstDayDigit = get_number_from_utf8_code(date[6]);\n        let secondDayDigit = get_number_from_utf8_code(date[7]);\n\n        let day = firstDayDigit * 10 + secondDayDigit;\n\n        Self { day: day, month: month, year: year }\n    }\n\n    pub fn from_str_short_year(date: str<6>, threshold_date: Date) -> Self {\n        let date_bytes = date.as_bytes();\n        Date::from_bytes_short_year(date_bytes, threshold_date)\n    }\n\n    pub fn from_str_long_year(date: str<8>) -> Self {\n        let date_bytes = date.as_bytes();\n        Date::from_bytes_long_year(date_bytes)\n    }\n\n    fn count_leap_years_since_epoch(year: u32, epoch_year: u32) -> u32 {\n        let y = year - 1;\n        let leaps_up_to_y = y / 4 - y / 100 + y / 400;\n        let leaps_up_to_epoch_year =\n            (epoch_year - 1) / 4 - (epoch_year - 1) / 100 + (epoch_year - 1) / 400;\n        leaps_up_to_y - leaps_up_to_epoch_year\n    }\n\n    fn days_since_epoch(year: u32, epoch_year: u32) -> u32 {\n        365 * (year - epoch_year) + Date::count_leap_years_since_epoch(year, epoch_year)\n    }\n\n    fn estimate_start_day_and_year(days: u32, epoch_year: u32) -> (u32, u32) {\n        let first_guess_year = epoch_year + days / 365;\n\n        let days_lower_bound = if first_guess_year > epoch_year {\n            Date::days_since_epoch(first_guess_year - 1, epoch_year)\n        } else {\n            0\n        };\n        let day_guess = Date::days_since_epoch(first_guess_year, epoch_year);\n        let days_upper_bound = Date::days_since_epoch(first_guess_year + 1, epoch_year);\n\n        let use_lower_bound = (days >= days_lower_bound) & (days < day_guess);\n        let use_upper_bound = days >= days_upper_bound;\n\n        let mut best_year = first_guess_year;\n        let mut best_start_day = day_guess;\n\n        best_year = if use_lower_bound {\n            first_guess_year - 1\n        } else {\n            best_year\n        };\n        best_start_day = if use_lower_bound {\n            days_lower_bound\n        } else {\n            best_start_day\n        };\n\n        best_year = if use_upper_bound {\n            first_guess_year + 1\n        } else {\n            best_year\n        };\n        best_start_day = if use_upper_bound {\n            days_upper_bound\n        } else {\n            best_start_day\n        };\n\n        (best_year, best_start_day)\n    }\n\n    pub fn from_timestamp_with_epoch(timestamp: u64, epoch_year: u32) -> Self {\n        let days = timestamp / SECONDS_IN_DAY as u64;\n        let (year, year_start_day) = Date::estimate_start_day_and_year(days as u32, epoch_year);\n        let day_of_year = days as u32 - year_start_day;\n\n        let is_leap = Date::is_leap_year(Date::new(year, 1, 1));\n\n        let days_at_month_start: [u32; 13] = if is_leap {\n            [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]\n        } else {\n            [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]\n        };\n\n        let mut month: u32 = 1;\n        for i in 0..12 {\n            let advance = day_of_year >= days_at_month_start[i + 1];\n            month = if advance { month + 1 } else { month };\n        }\n\n        let day: u32 = day_of_year - days_at_month_start[(month - 1) as u32] + 1;\n        Date::new(year, month as u8, day as u8)\n    }\n\n    pub fn from_timestamp(timestamp: u64) -> Self {\n        Date::from_timestamp_with_epoch(timestamp, UNIX_EPOCH_YEAR)\n    }\n\n    pub fn get_duration_in_days(self: Self, other: Self, absolute: bool) -> i64 {\n        let mut duration_years = self.get_duration_between_years(other);\n        let mut duration_months = self.get_duration_between_months(other);\n        let mut duration_days = self.day as i64 - other.day as i64;\n        if (self.year < other.year) {\n            if (other.is_leap_year() & other.month > 2 & self.month > 2) {\n                duration_days -= 1;\n            }\n        } else if (self.year > other.year) {\n            if (self.is_leap_year() & self.month > 2 & other.month > 2) {\n                duration_days += 1;\n            }\n        }\n        let totalDuration: i64 = duration_years + duration_months + duration_days;\n\n        if (totalDuration < 0) & absolute {\n            -1 * totalDuration\n        } else {\n            totalDuration\n        }\n    }\n\n    pub fn gt(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) > 0\n    }\n\n    pub fn lt(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) < 0\n    }\n\n    pub fn eq(self: Self, other: Self) -> bool {\n        (self.day == other.day) & (self.month == other.month) & (self.year == other.year)\n    }\n\n    pub fn ne(self: Self, other: Self) -> bool {\n        !self.eq(other)\n    }\n\n    pub fn gte(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) >= 0\n    }\n\n    pub fn lte(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) <= 0\n    }\n\n    pub fn println(self: Self) {\n        let year = self.year;\n        let month = self.month;\n        let day = self.day;\n        // Let's write the date in the YYYY-MM-DD format\n        // since people don't agree on which format is best\n        // between MM/DD/YYYY and DD/MM/YYYY\n        if (month < 10) & (day < 10) {\n            println(f\"Date: {year}-0{month}-0{day}\");\n        } else if month < 10 {\n            println(f\"Date: {year}-0{month}-{day}\");\n        } else if day < 10 {\n            println(f\"Date: {year}-{month}-0{day}\");\n        } else {\n            println(f\"Date: {year}-{month}-{day}\");\n        }\n    }\n\n    pub fn to_bytes(self: Self) -> [u8; 8] {\n        let mut date: [u8; 8] = [0; 8];\n\n        let firstYearDigit = self.year / 1000;\n        let secondYearDigit = (self.year - firstYearDigit * 1000) / 100;\n        let thirdYearDigit = (self.year - firstYearDigit * 1000 - secondYearDigit * 100) / 10;\n        let fourthYearDigit =\n            self.year - firstYearDigit * 1000 - secondYearDigit * 100 - thirdYearDigit * 10;\n\n        date[0] = number_to_utf8_code(firstYearDigit as u8);\n        date[1] = number_to_utf8_code(secondYearDigit as u8);\n        date[2] = number_to_utf8_code(thirdYearDigit as u8);\n        date[3] = number_to_utf8_code(fourthYearDigit as u8);\n\n        let firstMonthDigit = self.month / 10;\n        let secondMonthDigit = self.month - firstMonthDigit * 10;\n\n        date[4] = number_to_utf8_code(firstMonthDigit as u8);\n        date[5] = number_to_utf8_code(secondMonthDigit as u8);\n\n        let firstDayDigit = self.day / 10;\n        let secondDayDigit = self.day - firstDayDigit * 10;\n\n        date[6] = number_to_utf8_code(firstDayDigit as u8);\n        date[7] = number_to_utf8_code(secondDayDigit as u8);\n\n        date\n    }\n\n    pub fn to_string(self: Self) -> str<8> {\n        let date_bytes = self.to_bytes();\n        date_bytes.as_str_unchecked()\n    }\n\n    pub fn to_timestamp_with_epoch(self: Self, epoch_year: u32) -> u32 {\n        let days = self.get_duration_in_days(Date::new(epoch_year, 1, 1), true);\n        days as u32 * SECONDS_IN_DAY\n    }\n\n    pub fn to_timestamp(self: Self) -> u32 {\n        self.to_timestamp_with_epoch(UNIX_EPOCH_YEAR)\n    }\n\n    pub fn is_leap_year(self: Self) -> bool {\n        ((self.year % 4 == 0) & (self.year % 100 != 0)) | (self.year % 400 == 0)\n    }\n\n    pub fn leap_year_count(year: u32) -> i32 {\n        (year / 4) as i32 - (year / 100) as i32 + (year / 400) as i32\n    }\n\n    pub fn get_days_in_month(self: Self, month: u8) -> u8 {\n        assert(month >= 1 & month <= 12);\n        if month == 2 {\n            if self.is_leap_year() {\n                29\n            } else {\n                28\n            }\n        } else {\n            if (month == 1)\n                | (month == 3)\n                | (month == 5)\n                | (month == 7)\n                | (month == 8)\n                | (month == 10)\n                | (month == 12) {\n                31\n            } else {\n                30\n            }\n        }\n    }\n\n    pub fn get_duration_between_months(self: Self, other: Self) -> i64 {\n        assert(self.month >= 1 & self.month <= 12);\n        assert(other.month >= 1 & other.month <= 12);\n        let mut duration: i64 = 0;\n        if (self.month < other.month) {\n            for month in 1..13 {\n                if month >= self.month & month < other.month {\n                    duration -= other.get_days_in_month(month) as i64;\n                }\n            }\n        } else {\n            for month in 1..13 {\n                if month >= other.month & month < self.month {\n                    duration += self.get_days_in_month(month) as i64;\n                }\n            }\n        }\n        duration\n    }\n\n    pub fn get_duration_between_years(self: Self, other: Self) -> i64 {\n        let mut duration: i64 = 0;\n        if (self.year < other.year) {\n            let mut leap_year_count: i32 =\n                Date::leap_year_count(other.year - 1) - Date::leap_year_count(self.year);\n            if self.is_leap_year() {\n                leap_year_count += 1;\n            }\n            duration -= leap_year_count as i64 * 366;\n            duration -=\n                (other.year as i64 - self.year as i64 - leap_year_count as i64) as i64 * 365;\n        } else if (self.year > other.year) {\n            let mut leap_year_count: i32 =\n                Date::leap_year_count(self.year - 1) - Date::leap_year_count(other.year);\n            if other.is_leap_year() {\n                leap_year_count += 1;\n            }\n            duration += leap_year_count as i64 * 366;\n            duration +=\n                (self.year as i64 - other.year as i64 - leap_year_count as i64) as i64 * 365;\n        }\n        duration\n    }\n\n    pub fn add_years(self: Self, years: u32) -> Self {\n        Self { day: self.day, month: self.month, year: self.year + years }\n    }\n\n    pub fn sub_years(self: Self, years: u32) -> Self {\n        Self { day: self.day, month: self.month, year: self.year - years }\n    }\n\n    pub fn add_months(self: Self, months: u32) -> Self {\n        let mut newMonth = self.month as u32 + months;\n        let mut newYear = self.year;\n        let yearToAdd = (newMonth - 1) / 12;\n        if newMonth > 12 {\n            newYear += yearToAdd as u32;\n            newMonth -= 12 * yearToAdd;\n        }\n        Self { day: self.day, month: newMonth as u8, year: newYear }\n    }\n\n    pub fn sub_months(self: Self, months: u32) -> Self {\n        let mut newMonth = self.month as i32 - months as i32;\n        let mut newYear = self.year;\n        if newMonth < 1 {\n            let yearToSub = ((newMonth as i32 - 12 as i32) * -1) / 12;\n            newYear -= yearToSub as u32;\n            newMonth += 12 * yearToSub;\n        }\n        Self { day: self.day, month: newMonth as u8, year: newYear }\n    }\n\n    pub fn add_days(self: Self, days: u32) -> Self {\n        let mut newDay = self.day as u32 + days;\n        let mut newMonth = self.month as u32;\n        let mut newYear = self.year;\n        let mut date = Self { day: newDay as u8, month: newMonth as u8, year: newYear };\n        if newDay > self.get_days_in_month(self.month) as u32 {\n            let max_months = (newDay / 30) + 1;\n            let bound = self.month as u64 + max_months as u64;\n            for _ in self.month as u64..bound as u64 {\n                let days_in_month = date.get_days_in_month(newMonth as u8) as u32;\n                if newDay > days_in_month {\n                    newDay -= days_in_month;\n                    newMonth += 1;\n                    if newMonth > 12 {\n                        newYear += 1;\n                        newMonth = 1;\n                    }\n                    // We need to mutate the date object inside the loop\n                    // so we can use get_days_in_month properly\n                    date.day = newDay as u8;\n                    date.year = newYear;\n                    date.month = newMonth as u8;\n                }\n            }\n        }\n        date\n    }\n\n    // Performance could be improved\n    pub fn sub_days(self: Self, days: u32) -> Self {\n        let mut newDay = self.day as i32 - days as i32;\n        let mut newMonth = self.month as i32;\n        let mut newYear = self.year;\n        let mut date = Self { day: newDay as u8, month: newMonth as u8, year: newYear };\n        if newDay < 1 {\n            let max_months = (self.day as u32 + days) / 30 + 1;\n            let bound = self.month as u64 + max_months as u64;\n            for _ in self.month as u64..bound as u64 {\n                let days_in_month = date.get_days_in_month(newMonth as u8) as i32;\n                if newDay < 1 {\n                    newDay += days_in_month;\n                    newMonth -= 1;\n                    if newMonth < 1 {\n                        newYear -= 1;\n                        newMonth = 12;\n                    }\n                    // We need to mutate the date object inside the loop\n                    // so we can use get_days_in_month properly\n                    date.day = newDay as u8;\n                    date.year = newYear;\n                    date.month = newMonth as u8;\n                }\n            }\n        }\n        date\n    }\n}\n\nimpl Eq for Date {\n    fn eq(self: Self, other: Self) -> bool {\n        self.eq(other)\n    }\n}\n","path":"/Users/heeckhau/nargo/github.com/madztheo/noir-date.git/v0.5.4/src/date.nr"}},"names":["main"],"brillig_names":["print_unconstrained","print_unconstrained","directive_integer_quotient","directive_invert"]}