// THIS FILE WAS GENERATED BY `xtp-rust-bindgen`. DO NOT EDIT.

#![allow(non_snake_case)]
#![allow(unused_macros)]
use extism_pdk::*;

#[allow(unused)]
fn panic_if_key_missing() -> ! {
    panic!("missing key");
}

pub(crate) mod internal {
    pub(crate) fn return_error(e: extism_pdk::Error) -> i32 {
        let err = format!("{:?}", e);
        let mem = extism_pdk::Memory::from_bytes(&err).unwrap();
        unsafe {
            extism_pdk::extism::error_set(mem.offset());
        }
        -1
    }
}

#[allow(unused)]
macro_rules! try_input {
    () => {{
        let x = extism_pdk::input();
        match x {
            Ok(x) => x,
            Err(e) => return internal::return_error(e),
        }
    }};
}

#[allow(unused)]
macro_rules! try_input_json {
    () => {{
        let x = extism_pdk::input();
        match x {
            Ok(extism_pdk::Json(x)) => x,
            Err(e) => return internal::return_error(e),
        }
    }};
}

use base64_serde::base64_serde_type;

base64_serde_type!(Base64Standard, base64::engine::general_purpose::STANDARD);

mod exports {
    use super::*;

    #[no_mangle]
    pub extern "C" fn config() -> i32 {
        let ret = crate::config().and_then(|x| extism_pdk::output(extism_pdk::Json(x)));

        match ret {
            Ok(()) => 0,
            Err(e) => internal::return_error(e),
        }
    }

    #[no_mangle]
    pub extern "C" fn verify() -> i32 {
        let ret = crate::verify(try_input_json!()).and_then(extism_pdk::output);

        match ret {
            Ok(()) => 0,
            Err(e) => internal::return_error(e),
        }
    }
}

pub mod types {
    use super::*;

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub enum Direction {
        #[default]
        #[serde(rename = "Sent")]
        Sent,
        #[serde(rename = "Received")]
        Received,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct EncoderSecret {
        /// Delta used to generate the encodings
        #[serde(rename = "delta")]
        pub delta: Vec<i64>,

        /// Seed used to generate the encodings
        #[serde(rename = "seed")]
        pub seed: Vec<i64>,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct EncodingCommitment {
        /// Merkle root of the encoding commitments
        #[serde(rename = "root")]
        pub root: types::TypedHash,

        /// Secret used to generate the encodings
        #[serde(rename = "secret")]
        pub secret: types::EncoderSecret,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct PartialTranscript {
        /// Data received by the prover from the server (byte array)
        #[serde(rename = "received")]
        pub received: Vec<i64>,

        /// Index ranges of authenticated received data
        #[serde(rename = "recvAuthedIdx")]
        pub recv_authed_idx: Vec<types::Range>,

        /// Data sent from the prover to the server (byte array)
        #[serde(rename = "sent")]
        pub sent: Vec<i64>,

        /// Index ranges of authenticated sent data
        #[serde(rename = "sentAuthedIdx")]
        pub sent_authed_idx: Vec<types::Range>,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct PlaintextHash {
        /// Direction of the plaintext
        #[serde(rename = "direction")]
        pub direction: types::Direction,

        /// The hash of the data
        #[serde(rename = "hash")]
        pub hash: types::TypedHash,

        /// Indexes of the plaintext in the transcript
        #[serde(rename = "idx")]
        pub idx: Vec<types::Range>,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct PluginVerifierConfig {
        /// Maximum data that can be received by the prover in bytes
        #[serde(rename = "maxRecvData")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub max_recv_data: Option<i64>,

        /// Maximum number of application data records that can be received online
        #[serde(rename = "maxRecvRecordsOnline")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub max_recv_records_online: Option<i64>,

        /// Maximum data that can be sent by the prover in bytes
        #[serde(rename = "maxSentData")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub max_sent_data: Option<i64>,

        /// Maximum number of application data records that can be sent
        #[serde(rename = "maxSentRecords")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub max_sent_records: Option<i64>,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct Range {
        /// End position (exclusive)
        #[serde(rename = "end")]
        pub end: i64,

        /// Start position (inclusive)
        #[serde(rename = "start")]
        pub start: i64,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct TranscriptCommitment {
        /// Commitment to the encoding of the transcript data
        #[serde(rename = "encodingCommitment")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub encoding_commitment: Option<types::EncodingCommitment>,

        /// Hash of plaintext in the transcript
        #[serde(rename = "plaintextHash")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub plaintext_hash: Option<types::PlaintextHash>,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct TypedHash {
        /// The algorithm ID of the hash
        #[serde(rename = "alg")]
        pub alg: i64,

        /// The hash value in bytes
        #[serde(rename = "value")]
        pub value: Vec<i64>,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct VerifierOutput {
        /// The server's DNS name if revealed by the prover
        #[serde(rename = "serverName")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub server_name: Option<String>,

        /// The partial transcript containing authenticated application data
        #[serde(rename = "transcript")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub transcript: Option<types::PartialTranscript>,

        /// Cryptographic commitments to transcript data
        #[serde(rename = "transcriptCommitments")]
        pub transcript_commitments: Vec<types::TranscriptCommitment>,
    }
}


mod raw_imports {
    use super::*;
    #[host_fn]
    extern "ExtismHost" {}
}
